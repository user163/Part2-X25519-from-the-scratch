# curve25519 parameters
A = 486662 
B = 1
p = 2**255 - 19 # prime, order of Gallois field GF(p)
Gx = 9
Gy = 14781619447589544791020593568409986887264606134616475288964881837755586237401
l = 2**252 + 27742317777372353535851937790883648493 # order of G, = order of subgroup generated by G 

# from previous chapters ############################################################################

'''
Q1 <> Q2
Constraint: Q2 = Q1 + P
Q3 := Q1 + Q2
'''
def add_projective_constDiff(Q1, Q2, P):
    (X1, Z1) = Q1
    (X2, Z2) = Q2
    (PX, PZ) = P
    S = ((X2 - Z2) * (X1 + Z1)) % p
    T = ((X2 + Z2) * (X1 - Z1)) % p
    X3 = (PZ * pow(S + T, 2, p)) % p
    Z3 = (PX * pow(S - T, 2, p)) % p
    return (X3, Z3)

'''
Q3 = 2 * Q1
'''
def double_projective(Q1):
    (X1, Z1) = Q1
    X3 = (pow(X1 + Z1, 2, p) * pow(X1 - Z1, 2, p)) % p
    Z3 = (4 * X1 * Z1 * (pow(X1 - Z1, 2, p) + (A + 2) * X1 * Z1) ) % p
    return (X3, Z3)

def projective_to_compressed(q1):
    (x1, z1) = q1
    if (z1 == 0):
        return None
    return ((x1 * pow(z1, -1, p)) % p)

def compressed_to_projective(q1):
    if q1 == None:
        return (1,0)
    return (q1, 1)

# new ###############################################################################################

# Montgomery Ladder, time constant for scalars up to 256 bits
def point_multiplication(s, P):
    Q = (1,0)                           # neutral element
    R = P
    bits = bin(s)[2:]                   # bit encoding of s
    bitsPadded = bits.rjust(256, '0')   # the bit representation of all scalars is extended with leading 0 to 256 bit 
    for b in bitsPadded:                # for each step, the same operations are done, no matter if the bit is 0 or 1
        if b == '0':
            R = add_projective_constDiff(Q, R, P) # Q + R with R = Q + P
            Q = double_projective(Q)
            
        else:
            Q = add_projective_constDiff(Q, R, P) # Q + R with R = Q + P
            R = double_projective(R)
    return Q
  
#
# test
#

G = compressed_to_projective(Gx)

res1_1G = point_multiplication(1, G)
print("1G:       " + str(projective_to_compressed(res1_1G)))
   
res2_2G = point_multiplication(2, G)
print("2G:       " + str(projective_to_compressed(res2_2G)))

res3_3G = point_multiplication(3, G)
print("3G:       " + str(projective_to_compressed(res3_3G)))

res4_4G = point_multiplication(4, G)
print("4G:       " + str(projective_to_compressed(res4_4G)))

res5_5G = point_multiplication(5, G)
print("5G:       " + str(projective_to_compressed(res5_5G)))

res6_25G = point_multiplication(25, G)
print("25G:      " + str(projective_to_compressed(res6_25G)))

res7_25G = point_multiplication(5, res5_5G)
print("25G:      " + str(projective_to_compressed(res7_25G)))

res8_125G = point_multiplication(125, G)
print("125G:     " + str(projective_to_compressed(res8_125G)))

res9_125G = point_multiplication(25, res5_5G)
print("125G:     " + str(projective_to_compressed(res9_125G)))

res10_125G = point_multiplication(5, res7_25G)
print("125G:     " + str(projective_to_compressed(res10_125G)))